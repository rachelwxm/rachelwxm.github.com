<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: R | Blog{Rachel|BENM}]]></title>
  <link href="http://rachelwxm.github.io/blog/category/r/atom.xml" rel="self"/>
  <link href="http://rachelwxm.github.io/"/>
  <updated>2014-07-23T10:49:52+08:00</updated>
  <id>http://rachelwxm.github.io/</id>
  <author>
    <name><![CDATA[Wu Xiaomeng(Rachel)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[R-函数]]></title>
    <link href="http://rachelwxm.github.io/blog/2014/04/14/r-han-shu/"/>
    <updated>2014-04-14T17:37:39+08:00</updated>
    <id>http://rachelwxm.github.io/blog/2014/04/14/r-han-shu</id>
    <content type="html"><![CDATA[<h5><em>Computing for Data Analysis, week2-Functions</em></h5>

<h3>函数构建(Function)</h3>

<p>通过function()自定义函数，构建格式为：<br/>
```r
f&lt;-function(<arguments>){</p>

<pre><code>##do sth 
</code></pre>

<p>}
```</p>

<!--more-->


<p>示例：<br/>
```r</p>

<pre><code>&gt;echo&lt;-function(x)    #定义名为echo的函数
+{
+   print(x)
+   str(x)
+}
&gt;z=1:3
&gt;echo(z)
[1] 1 2 3
 int [1:3] 1 2 3
</code></pre>

<p>```</p>

<h3>函数参数(Function Arguments)</h3>

<ul>
<li><code>formals()</code>查看指定函数的参数，结果将以list形式返回</li>
<li><code>args()</code>以简化的显示方式返回函数参数</li>
</ul>


<h3>参数匹配(Argument Matching)</h3>

<p>对于任何一个有名字的参数(named argument)，所以使用函数时有名字参数的引用顺序对结果没有影响。以下调用函数的语句具有同样的作用。<br/>
```r</p>

<pre><code>&gt; mydata &lt;- rnorm(100)         #生成一组随机数
&gt; sd
function (x, na.rm = FALSE)    #函数sd有两个参数，na.rm有默认参数
&gt; sd(mydata)                   #按顺序将第一个值赋给“x”
&gt; sd(x = mydata)               #按名字赋值
&gt; sd(x = mydata, na.rm = FALSE) #按名字赋值，因为na.rm的默认值也是FALSE，所以可写可不写
&gt; sd(na.rm = FALSE, x = mydata) #指定名字赋值，调换顺序没有影响
&gt; sd(na.rm = FALSE, mydata)     #第一个参数指定名字，未指定名称的输入值自动赋给尚未赋值的第一个参数x
</code></pre>

<p><code>
函数参数赋值顺序在多参数函数中体现的更加明显。无名称输入值将按照瞬息自动分配给尚未指定值的参数。  
</code>r</p>

<pre><code>&gt; args(lm)
function (formula, data, subset, weights, na.action,
    method = "qr", model = TRUE, x = FALSE,
    y = FALSE, qr = TRUE, singular.ok = TRUE,
    contrasts = NULL, offset, ...)
#下面两种引用方式具有相同效果
&gt;lm(data = mydata, y ~ x, model = FALSE, 1:100) 
&gt;lm(y ~ x, mydata, 1:100, model = FALSE)
</code></pre>

<p>```</p>

<h3>惰性求值(Lazy Evaluation)</h3>

<p>惰性求值的原则是除非有需要，否则不计算，所以有名字的参数也不一定会被使用。例如一下函数定义及使用中不会报错。</p>

<blockquote><p>The lazy evaluation applies because the argument is only evaluated when it&rsquo;s needed. <br/>
```r</p>

<pre><code>&gt;f&lt;-function(a,b){    #定义函数f，有两个命名参数
+   a^2
+}
&gt;f(2)
4
</code></pre>

<p><code>
因为函数f没有用到参数b，所以即使b没有默认参数而且没有输入参数，程序依然不会报错。另外一个例子：  
</code>r</p>

<pre><code>&gt;f &lt;- function(a, b) {
+   print(a)
+   print(b)
+}
&gt; f(45)        #执行函数f，因为只输入了一个参数值，按顺序将赋值给参数a，参数b没有值
[1] 45
Error in print(b) : argument "b" is missing, with no default
</code></pre>

<p><code>``
注意到“45”先于报错信息打印出来，这是因为关于参数b的运算是在运行</code>print(a)`语句之后。</p>

<h3>点点点参数(Three-dots Argument or &ldquo;&hellip;&rdquo; Argument)</h3>

<p>&hellip;参数表示一系列用于传递到其他函数的可变数目的参数。</p></blockquote>

<ul>
<li>任意参数(Arbitrary arguments)</li>
</ul>


<p>以函数<code>c</code>和<code>list</code>为例：<br/>
```r</p>

<pre><code>&gt; c
function (..., recursive = FALSE)  .Primitive("c")
&gt; list
function (...)  .Primitive("list")
</code></pre>

<p><code>
这两个函数都允许用户输入随意数目参数，并且可以有用户命名这些参数。  
</code>r</p>

<pre><code>&gt; c(a=42, 73.9, c=NA)
   a         c 
42.0 73.9   NA 
&gt; names(.Last.value)
[1] "a" ""  "c"
</code></pre>

<p>```
+ 传递参数(Passing arguments on)
当函数中嵌套其他函数，而你不想复制嵌套函数中所有的参数列表时，可以使用&hellip;参数。</p>

<p>需要注意的是在“&hellip;”之后的参数必须使用参数名字赋值。</p>

<h3><strong>参考资料</strong></h3>

<p>[1]慕容飞宇. (2012-11-03) R 函数.  <br/>
<a href="http://jiaoyan.org/r/?page_id=1091">http://jiaoyan.org/r/?page_id=1091</a> <br/>
[2]Burns. (2013-01-30) The three-dots construct in R.   <br/>
<a href="http://www.burns-stat.com/the-three-dots-construct-in-r/">http://www.burns-stat.com/the-three-dots-construct-in-r/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R的控制结构]]></title>
    <link href="http://rachelwxm.github.io/blog/2014/04/13/rde-kong-zhi-jie-gou/"/>
    <updated>2014-04-13T16:40:50+08:00</updated>
    <id>http://rachelwxm.github.io/blog/2014/04/13/rde-kong-zhi-jie-gou</id>
    <content type="html"><![CDATA[<h5><em>Computing for Data Analysis, week2-Control Structures</em></h5>

<p>与其他编程语言一样，R也有多种循环控制结构，比如：if/else判断语句、for循环、while循环、repeat重复结构等。</p>

<!--more-->


<h3>if</h3>

<p><code>if</code>判断语句可单独使用或结合<code>else</code>一起使用：  <br/>
```r</p>

<pre><code>&gt;if(&lt;condition&gt;){ ##do sth}  #单独使用if
&gt;if(&lt;condition&gt;){            
+ ##do sth
+} else if(&lt;condition2&gt;){    #结合else，分条件判断、执行
+  ##do sth else
+ }else{
+  ##do sth else
+ }
</code></pre>

<p><code>
实例
</code>r</p>

<pre><code>if(x&gt;3){    #如果x大于3,则给y赋值10;否则给y赋值0
    y&lt;-10
}else{
    y&lt;-0
}
</code></pre>

<p>```</p>

<h3>for</h3>

<p>R的<code>for</code>循环架构如下：
```r</p>

<pre><code>&gt;for(name in expr1) {expr2}
</code></pre>

<p><code>
其中name是循环变量，expr1是一个向量表达式，用来给name赋值，常用的数据结构有list、vector等；expr2是循环中运行的语句。一个简单的实例如下：  
</code>r</p>

<pre><code>for(i in 1:10){    #i是循环变量，1：10是i取值的向量表达式
    print(i)       #expr2
}
</code></pre>

<p><code>
循环变量还可以像下面这样写，如下几个循环有同样的效果：  
</code>r</p>

<pre><code>&gt;x&lt;-c("a","b","c","d")   #给向量x赋值
&gt;for(i in 1:4){          #常规写法，给循环变量一个新的赋值表达式1:4
+   print(x[i])          #打印出向量x中对应位置的值
+}
&gt;for(i in seq_along(x)){ #seq_along()是一个函数，会构建一个从1开始和输入向量同等长度的整数向量，不清楚的话可以在R中输入“?seq_along()”看看函数用法
+   print(x[i])
+}
&gt;for(letter in x){       #letter直接在向量x中取值，与perl的foreach $letter(@x){}是一个意思
+   print(letter)
+}
</code></pre>

<p><code>
R也允许使用嵌套循环，比如：  
</code>r</p>

<pre><code>&gt;x &lt;- matrix(1:6, 2, 3)          #新建矩阵x，并赋值
&gt;for(i in seq_len(nrow(x))) {    #seq_len(nrow(x))返回的向量值是1 2，也就是矩阵x的行数
+   for(j in seq_len(ncol(x))) { 
+       print(x[i, j])           #先按行、再按列打印出矩阵x的值
+   }
+}
[1] 1
[1] 3
[1] 5
[1] 2
[1] 4
[1] 6
</code></pre>

<p>```</p>

<h3>while</h3>

<p><code>while</code>循环执行之前先判定设置条件是否为真，是则执行循环内容，再次判定设置条件是否为真；否则跳出循环。使用语法为<code>while(&lt;expr1&gt;){expr2}</code>，若expr1运算结果成立，则执行expr2。需要注意的是要保证在有限循环次数内是expr1不成立，即不要陷入死循环中。<br/>
```r</p>

<pre><code>&gt;count&lt;-0            #给count赋值为0
&gt;while(count&lt;10){    #括号中的内容“count&lt;10”是判定条件，判定条件可以是单一表达式，也可以是多个表达式的逻辑运算结果
+   print(count)     #打印结果为从0至9共10个数字
+   count&lt;-count+1   #每执行一次循环，count加1
+}
</code></pre>

<p>```</p>

<h3>repeat</h3>

<p><code>repeat</code>是一个无限重复的循环，退出的<code>repeat</code>循环的唯一方法是使用<code>break</code>语句。使用repeat会有一些危险，因为无法保证它一定会终止，很容易陷入到无限循环中。如果一定要使用，建议用更加严格的条件控制。示例如下：  <br/>
```r</p>

<pre><code>&gt;z&lt;-5
&gt;count&lt;-1
&gt;repeat{
+   print(z)
+   coin&lt;-rbinom(1,1,0.5)  #生成一个随机数coin
+   if(z&lt;3 || z&gt;10){       #判定条件是否成立，若成立则跳出repeat循环
+       break
+   }else{
+       if(coin ==1 ){z&lt;-z+1} 
+       else{z&lt;-z-1}
+   }
+   if(count&gt;10000){break} #设定一个循环的最大次数，保证程序不会跑死
+   count&lt;-count+1
+}
</code></pre>

<p>```</p>

<h3>next和return</h3>

<p><code>next</code>用来跳过当前循环，执行下一个循环；return跳出循环结构并返回一个值。<br/>
```r</p>

<pre><code>&gt;for(i in 1:100) {
+   if(i &lt;= 20) {
+       next      #跳过前20个循环
+   }
+   ## Do something here
+}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读入数据]]></title>
    <link href="http://rachelwxm.github.io/blog/2014/01/21/reading-and-writing-data-1/"/>
    <updated>2014-01-21T02:11:15+08:00</updated>
    <id>http://rachelwxm.github.io/blog/2014/01/21/reading-and-writing-data-1</id>
    <content type="html"><![CDATA[<h5><em>Computing for Data Analysis, week1-Reading and Writing Data</em></h5>

<h3>读入数据(Reading and Writing Data)</h3>

<p>有以下几个主要的函数用来将数据读入R中：</p>

<ul>
<li><code>read.table</code>和<code>read.csv</code>用来读入表格数据，生成数据框</li>
<li><code>readLines</code>用来读入文本文件(text)，生成字符向量</li>
<li><code>source</code>读入R代码(inverse of dump)</li>
<li><code>dget</code>读入R代码(inverse of dput)</li>
<li><code>load</code>读入工作空间(workspaces)内容</li>
<li><code>unserialize</code>读入二进制的R对象</li>
</ul>


<!--more-->


<p>与读入数据类似，也有相应的函数用来将数据写到文件中。</p>

<ul>
<li>write.table</li>
<li>writeLines</li>
<li>dump</li>
<li>dput</li>
<li>save</li>
<li>serialize</li>
</ul>


<h4>read.table</h4>

<p><code>read.table</code>是最常用的读入数据的函数之一，它有几个重要的参数：</p>

<ul>
<li>file，文件名称</li>
<li>header，逻辑值，表征读入的数据是否有header line</li>
<li>sep，字符串的分割方式，如",&ldquo;、tab、&rdquo; &ldquo;&hellip;&hellip;</li>
<li>colClasses，一个字符串向量用于指示每一列数据的数据类型</li>
<li>nrows，数据的行数</li>
<li>comment.char，一个字符串用于指示注释标示，比如常用的有英镑符号或者井号(#)</li>
<li>skip，从前面跳过多少行开始读入</li>
<li>stringsAsFactors，是否从读入数据中自动识别为因子</li>
</ul>


<p>用<code>read.table</code>读入小的文件时无需指定任何参数（如果设定参数，R将运行得更快、更高效）。<br/>
```r</p>

<pre><code>data &lt;- read.table("foo.txt")  
</code></pre>

<p><code>
R会    
• 自动跳过以“#”开头的行   
• 自动识别出有多少行，需要用多少内存  
• 自动识别每列元素的数据类型   
`read.csv`默认识别的分隔符是逗号，而`read.rable`默认的分隔符是空格。
用`read.table`读入大文件时，进行一下操作将有助于防止R跑死：  
• 阅读`read.table`的帮助文件将会发现很多重要的提示  
• 粗略估计将读入的数据会占用多少内存  
• 如果读入文件中没有注释行，设置`comment.char = ""`将加快读入速度  
• 指定更多详细的参数将对读入速度有大大的提高  
</code>r
initial &lt;&ndash; read.table(&ldquo;datatable.txt&rdquo;, nrows = 100)
classes &lt;&ndash; sapply(initial, class)
tabAll &lt;&ndash; read.table(&ldquo;datatable.txt&rdquo;, colClasses = classes)
```</p>

<h4>计算内存需求</h4>

<p>假设一个文件有1,500,000行，120列，所有的数据都是数字，粗略计算需要占用的存储内存有：<br/>
1,500,000 × 120 × 8 bytes/numeric = 1440000000 bytes = 1.34G <br/>
可以通过<code>version</code>命令查看当前运行机的系统信息，进而判断是否读入该文件。</p>

<h4>按行读取文档（Reading Lines of a Text File）</h4>

<p>```r</p>

<blockquote><p>con&lt;-gzfile(&ldquo;words.gz&rdquo;)    #用函数<code>gzfile</code>打开压缩文件
x&lt;-readLines(con,10)    #只读取该文件前十行
x
 [1] &ldquo;1080&rdquo; &ldquo;10-point&rdquo; &ldquo;10th&rdquo; &ldquo;11-point&rdquo;
 [5] &ldquo;12-point&rdquo; &ldquo;16-point&rdquo; &ldquo;18-point&rdquo; &ldquo;1st&rdquo;
 [9] &ldquo;2&rdquo; &ldquo;20-point&rdquo;
```</p>

<h4>读取网络文件</h4>

<p><code>r
con &lt;- url("http://www.jhsph.edu", "r")    #用函数`url`读取网络文件
x &lt;- readLines(con)
head(x)    #默认显示前6行
[1] "&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"&gt;"
[2] ""
[3] "&lt;html&gt;"
[4] "&lt;head&gt;"
[5] "\t&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8
</code></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[矢量化操作]]></title>
    <link href="http://rachelwxm.github.io/blog/2014/01/21/vectorized-operations/"/>
    <updated>2014-01-21T02:08:34+08:00</updated>
    <id>http://rachelwxm.github.io/blog/2014/01/21/vectorized-operations</id>
    <content type="html"><![CDATA[<h5><em>Computing for Data Analysis, week1-Vectorized Operations</em></h5>

<h3>矢量化操作(Vectorized Operations)</h3>

<p>在R中的很多操作都是矢量化的，使得R的代码更加高效、简洁、易懂。<br/>
```r</p>

<pre><code>&gt; x &lt;- 1:4; y &lt;- 6:9    #新建两个向量x和y
&gt; x+y    #对两个长度相同或者长度成倍数关系的向量执行加法运算
[1]  7  9 11 13
&gt; x * y   #对两个长度相同或者长度成倍数关系的向量执行乘法运算
[1]  6 14 24 36
</code></pre>

<p>```</p>

<!--more-->


<p>矢量化矩阵运算<br/>
```r</p>

<pre><code>&gt; x &lt;- matrix(1:4, 2, 2); y &lt;- matrix(rep(10, 4), 2, 2)
&gt; x
     [,1] [,2]
[1,]    1    3
[2,]    2    4
&gt; y
     [,1] [,2]
[1,]   10   10
[2,]   10   10
&gt; x * y    #矩阵点乘
     [,1] [,2]
[1,]   10   30
[2,]   20   40
&gt; x %*% y    #矩阵乘法
     [,1] [,2]
[1,]   40   40
[2,]   60   60
&gt; x/y    #两个矩阵对应元素除法
     [,1] [,2]
[1,]  0.1  0.3
[2,]  0.2  0.4
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R的数据类型-2]]></title>
    <link href="http://rachelwxm.github.io/blog/2014/01/19/r-datatype-2/"/>
    <updated>2014-01-19T03:09:28+08:00</updated>
    <id>http://rachelwxm.github.io/blog/2014/01/19/r-datatype-2</id>
    <content type="html"><![CDATA[<h5><em>Computing for Data Analysis, week1-Subsetting</em></h5>

<h3>子集(Subsetting)</h3>

<p>提取R中元素子集的方法：</p>

<ul>
<li>选择一个向量中元素的子集（一个或多个元素）可以通过在其名称后追加一个方括号<code>[</code>中的索引向量来完成；</li>
<li><code>[[</code>用来提取列表或者数据框中的元素，这种方式只可以提取一个元素；</li>
<li><code>$</code>用来根据名称提取列表或数据框中的元素。</li>
</ul>


<!--more-->


<p><p>
```r</p>

<pre><code>&gt; x &lt;- c("a", "b", "c", "c", "d", "a")
&gt; x[1]    #提取向量x中的第一个元素
[1] "a"
&gt; x[1:4]    #提取向量x中第一至第四个元素
[1] "a" "b" "c" "c"
&gt; x[x &gt; "b"]    #提取向量x中大于b的元素
[1] "c" "c" "d"
&gt; u &lt;- x &gt; "a"    #创建一个逻辑向量u，逻辑值是x中的每个元素是否大于a
&gt; u
[1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE
&gt; x[u]
[1] "b" "c" "c" "d"
</code></pre>

<p>```</p>

<h4>构造矩阵子集(Subsetting a Matrix)</h4>

<p>矩阵子集可通过元素脚标获取，形如<code>(i,j)</code>，i表示行数，j表示列数。<br/>
```r</p>

<pre><code>&gt; x &lt;- matrix(1:6, 2, 3)    #构建矩阵x，元素内容为1~6数字，矩阵有2行3列
&gt; x
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
&gt; x[1, 2]    #提取矩阵x中第1行第2列的元素
[1] 3
&gt; x[2, 1]    #提取矩阵x中第2行第1列的元素
[1] 2    
&gt; x[1, ]    #提取矩阵x中第1行的所有元素
[1] 1 3 5
&gt; x[, 2]    #提取矩阵x中第2列的所有元素
[1] 3 4
&gt; x[, 2,drop=FALSE]    #drop参数默认是TRUE，当设置其为FALSE时，返回的元素将以矩阵形式表示，而不是向量形式
     [,1]
[1,]    3
[2,]    4
&gt; x[1:2, 2:3]
     [,1] [,2]
[1,]    3    5
[2,]    4    6
</code></pre>

<p>```</p>

<h4>构造列表子集(Subsetting Lists)</h4>

<p>```r</p>

<blockquote><p>x &lt;&ndash; list(foo = 1:4, bar = 0.6, baz=&ldquo;hello&rdquo;)
x
$foo
[1] 1 2 3 4</p></blockquote>

<p>$bar
[1] 0.6</p>

<p>$baz
[1] &ldquo;hello&rdquo;</p>

<blockquote><p>x[1]    #单个中括号`[`获取列表元素将返回列表形式
$foo
[1] 1 2 3 4</p>

<p>x[[1]]    #双中括号`[[`将只返回元素内容
[1] 1 2 3 4
x$bar
[1] 0.6
x[[&ldquo;bar&rdquo;]]    #同x$bar效果相同
[1] 0.6
x[&ldquo;bar&rdquo;]
$bar
[1] 0.6
x[c(1, 3)]    #如果想获取列表中的多个元素，只能用单中括号`[`
$foo
[1] 1 2 3 4</p></blockquote>

<p>$baz
[1] &ldquo;hello&rdquo;
```</p>

<blockquote><p>请注意区分Lst[[1]]和Lst[1]，'[[&hellip;]]&lsquo;是选择单个元素时使用的操作符，而&rsquo;[&hellip;]&lsquo;是一个一般的下标操作符。因此，前者代表列表Lst中的第一个对象，而且如果列表已命名，对象的名称并不包含在所指定的对象里；后者是列表Lst的子列表，仅包含列表的第一项。而如果列表已命名，其名称也包含到所指定的对象里。</p></blockquote>

<p>双中括号<code>[[</code>和美元符号<code>$</code>用于引用：<br/>
```r</p>

<pre><code>&gt; x &lt;- list(foo = 1:4, bar = 0.6, baz = "hello")
&gt; name &lt;- "foo"
&gt; x[[name]]    #输出x[["foo"]]的结果
[1] 1 2 3 4
&gt; x$name    #元素name不存在，在这里会把name当做x中的元素判断
NULL
&gt; x$foo    #元素foo存在
[1] 1 2 3 4
</code></pre>

<p><code>
双中括号其他用法：  
</code>r</p>

<pre><code>&gt; x &lt;- list(a = list(10, 12, 14), b = c(3.14, 2.81))
&gt; x[[c(1, 3)]]    #提取列表x中第1个对象中的第3个元素
[1] 14
&gt; x[[1]][[3]]    #效果同上
[1] 14
&gt; x[[c(2, 1)]]    #提取列表x中第2个对象中的第1个元素
[1] 3.14
</code></pre>

<p>```</p>

<h4>部分匹配(Partial Matching)</h4>

<p>在<code>[[</code>和<code>$</code>提取子集时允许部分匹配。<br/>
```r</p>

<pre><code>&gt; x &lt;- list(aardvark = 1:5,abcc=6:8)
&gt; x$a
NULL
&gt; x$ab    #因为列表x的对象中ab开头的只有“abcc”
[1] 6 7 8
&gt; x$aa
[1] 1 2 3 4 5
&gt; x[["ab"]]
NULL
&gt; x[["ab",exact=FALSE]]    #\`[[\`模式中默认extact参数是TRUE，不支持部分匹配
[1] 6 7 8
</code></pre>

<p>```</p>

<h3>移除空值(Removing NA Values)</h3>

<p>```r</p>

<pre><code>&gt; x &lt;- c(1, 2, NA, 4, NA, 5)
&gt; bad&lt;- is.na(x)    #构建逻辑向量bad，其中的元素是x中是否是空值
&gt; bad
[1] FALSE FALSE  TRUE FALSE  TRUE FALSE
&gt; x[!bad]
[1] 1 2 4 5
</code></pre>

<p><code>
用函数`complete.cases`对多个对象同时移除空值  
</code>r</p>

<pre><code>&gt; x &lt;- c(1, 2, NA, 4, NA, 5)
&gt; y &lt;- c("a", NA,"b", "d", NA, "f")
&gt; good &lt;- complete.cases(x, y)    #判断x和y每个位置上都不是空值则为TRUE，否则为FALSE
&gt; good
[1]  TRUE FALSE FALSE  TRUE FALSE  TRUE
&gt; x[good]
[1] 1 4 5
&gt; y[good]
[1] "a" "d" "f"
</code></pre>

<p>```</p>

<h2>参考资料</h2>

<p>[1] R Development Core Team. R语言简介-R语言笔记:数据分析与绘图的编程环境[M].1.7版. 2006.</p>
]]></content>
  </entry>
  
</feed>
